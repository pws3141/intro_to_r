---
title: "An Introduction to R"
author: "Paul Smith"
format: 
  html:
    embed-resources: true
    code-annotations: hover
    grid:
      margin-width: 350px
    fig-width: 6
    fig-asp: 0.618
    toc: true
    toc-location: left
bibliography: ref.bib
reference-location: margin
citation-location: margin
fig-cap-location: margin
tbl-cap-location: margin
link-citations: true
---

## Installing R and RStudio

R is the main software we need, and RStudio is an IDE to make it easier to use R. You can run R without RStudio (*e.g.* in the terminal or using the packaged R GUI), but it is highly recommended to use RStudio as it makes your life a lot easier.

**Method 1: Using the latest versions**

Ideally, you should install the latest versions of R and RStudio from the websites. This requires a servicenow request. My request code was 'RITM0325475' if you want to quote this when requesting R and RStudio, and my request can be seen in @fig-servicenow.

You should also download the latest RTools software from Software Centre.

::: {.column-margin}
![My ServiceNow software request](./fig/servicenow.png){.lightbox #fig-servicenow}
:::

**Method 2: using software centre**

Install the latest R (currently 4.3.1), RTools (4.4), and RStudio (2022.07.2-576) from Software Centre. Install them in that order as you need R installed before using RStudio.

### Testing it all works

Once you have install R, RTools and RStudio, check it all works by starting up RStudio. It should look similar to @fig-rstudio.

![RStudio should look very similar to this when opened for the first time. The console (left-hand pane) is where you can type commands for R.](./fig/rstudio.png){.lightbox #fig-rstudio}

## Getting Started with R

In it's simplest form, R is just a calculator. In the console, try typing `6 + 8`. The output should look like

```{r}
#| echo: false

6 + 8
```

Note that the `[1]` just indicates that the line begins with the first value in your result. We only have one value here, `r 6 + 8`, so it's not very informative. 

We can *assign* values to variables using `<-`.^[You can also use the equals sign `=`, although I prefer only using this when assigning values to function arguments, which we'll get to later.] Let's assign our `6 + 8` to the variable `x`,

```{r}
x <- 6 + 8
```

To check that we have assigned this correctly, just type `x` in the console,

```{r}
x
```

The main R data types are vectors, matrices and dataframes and tibbles. Tibbles are the odd one out here, as they don't come with base R, but are instead from a package known as {tidyverse}.

### Vectors

Vectors are created using the `c()` function. For example, to create a vector of length four with elements 1, 3, 5 and 2, we write,

```{r}
c(1, 3, 5, 2)
```

As before, we can assign this to a variable.^[Here, I am overwriting the `x` variable we assigned earlier.]

```{r}
x <- c(1, 3, 5, 2)
```

R is case-sensitive, so `x` and `X` are different. If you type them both into the console, you should see an error message similar to below.

```r
> x
[1] 1 3 5 2
> X
Error: object 'X' not found
```

You can extract elements of vectors using square backets. You can also write comments by starting a line with a `#`.

```{r}
# get the 1st element of x
x[1] # <1>
```

1. Note that with R, the first element is in position 1. This is different to *e.g.* python, where the indexing starts at 0.

```{r}
# get the 3rd element
x[3]
```

```{r}
# get the 2nd and 4th element
x[c(2, 4)]  # <1>
```

1. Here, there is a vector inside the square brackets. See what happens if you type `x[2, 4]` - this will be discussed in the Matrix section below.

Vector operations are done element-wise.

```{r}
# square each element of x
x^2

y <- c(1, 0, 4, 2)
# add each element of x to y
x + y
# multiple each element of x by y
x * y
```

:::{.callout-warning}

R sometimes silently recycles vectors if they are of different lengths, for example,

```{r}
m <- 1:10 # equivalent to c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
n <- c(-1, 1)

m * n
```
It will give a warning though if the length of the shorter vector does not divide into the length of the longer vector.

```{r}
m <- 1:10 # equivalent to c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
n <- c(-1, 0, 1)

m * n
```

:::

The elements of vectors have to be all the same type, *e.g.* all numeric, or all characters. If you mix them, then R will change them to be the same. For example, the elements of `z` below are all changed to strings (which can be seen by the quotation marks around each element).

```{r}
z <- c(0, 7, "cat", as.Date("1992-09-11"))

z
```

### Matrices

Matrices a two-dimensional objects which -- like vectors -- are all of the same type.

```{r}
X <- matrix(data = 1:12, nrow = 3)
X
```

Here, we have coerced a vector `1:12` into a matrix with three rows. The elements have been inserted into the matrix column-wise. The object `matrix()` is actually a function^[similar to a macro in SAS], which we will discuss later in @sec-gettingStarted-functions. We can look at the help file by typing `?matrix` into the console. Under 'Usage', we can see that the `matrix()` function has the following arguments:^[Here, the equals sign is used as opposed to `<-` as we are assigning values to function arguments.]

```
matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE,
       dimnames = NULL)
```

Arguments can either be called using the name, *e.g.* `data = `, or by their position. Often, the first one or two arguments are so regularly used that they are not called explicitly. For example, the following will produce the exact same matrix.

```r
X <- matrix(1:12, nrow = 3)
```

The number of columns has been calculated automatically given the length of the `data` and the `nrow` argument, so the following will produce the same matrix again:

```r
X <- matrix(1:12, nrow = 3, ncol = 4)
```
We can also set the matrix to be filled row-wise using the `byrow` argument, to create a different matrix,

```{r}
matrix(1:12, nrow = 3, byrow = TRUE) # <1>
```

1. Here we are not assigning this matrix to a variable, so it will just print out in the console and not save anywhere.

We can extract elements using square brackets, but this time there are two dimensions, so we use a comma to separate the row index with the column index.

:::{.column-margin}
Recall that the matrix $X$ is,
```{r}
#| echo: false
X
```
:::

```{r}
# obtain the element in the second row and third column
X[2, 3]
```

```{r}
# obtain the third row
X[3, ] # <1>
```
1. Leaving the index blank means all the elements will be used. Note the output is now a one-dimensional vector.

```{r}
# first and third column
X[, c(1, 3)] # <2>
```
2. This outputs a (smaller) matrix.

Matrix multiplication is done using `%*%`. To multiple `X` with the transpose of `X`, *i.e.*

$$
\begin{pmatrix}
1 & 4 & 7 & 10 \\
2 & 5 & 8 & 11 \\
3 & 6 & 9 & 12 \\
\end{pmatrix}
\cdot
\begin{pmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9 \\
10 & 11 & 12 \\
\end{pmatrix}
$$

we would write,

```{r}
X %*% t(X)
```

Similarly, multiplying a matrix with a vector, `x <- c(1, 3, 5, 2)`, that is,

$$
\begin{pmatrix}
1 & 4 & 7 & 10 \\
2 & 5 & 8 & 11 \\
3 & 6 & 9 & 12 \\
\end{pmatrix}
\cdot
\begin{pmatrix}
1  \\
3  \\
5  \\
2 \\
\end{pmatrix}
$$

```{r}
X %*% x
```

You can use the normal multiplication, `*`, to multiply element-wise,

```{r}
# multiple every element by 5
X * 5

X * c(1, -1, 0)
```

### Dataframes

Dataframes are ways to store different types of data in one place - similar to how SAS datasets contain different types of data (numeric, character, logical, dates *etc.*).

```{r}
df <- data.frame(
  some_numbers = c(1, 2, 3),
  strings = c("a", "b", "c"),
  logical_stuff = c(TRUE, FALSE, TRUE),
  some_dates = as.Date(c("2025-01-01", "2025-01-02", "2025-01-03"))
)

class(df)

df
```
You can extract columns using either their index or the column names with the `$` symbol. To obtain the second column, we can do either:

```{r}
df[, 2]
df$strings
```


### Tibbles

Tibbles are modern versions of dataframes. They require the {tidyverse} package [@wickham2019tidyverse] to be installed. To do this, type `install.packages("tidyverse")` in the console. This only needs to be done once and installs the package onto the computer. Then, to use the package, we call it using the `library()` function, which needs to be run every time you start a new session.

```{r}
library(tidyverse)
```
The {tidyverse} package comes with some datasets, which we can have a look at to see an example of a tibble. A big difference between a tibble and a dataframe is in how it is visualised in the console -- tibbles show the `class` of each column and truncate the number of rows and columns shown if the dataset is large.

```{r}
mpg
```

The `glimspe()` function is very useful when looking at the data, especially if the tibble has lots of columns.

```{r}
glimpse(mpg)
```

### Functions

Functions are the R equivalent of SAS macros. 
R has a large number of inbuilt functions, such as `seq()`, `mean()`, `sum()`, `lm()`.^[A note on notation: if I am refering to a function in R, I will always include brackets at the end `()`.]

Type `?seq` into the console. If you start typing, *e.g.* `?s`, and then press TAB, RStudio will give you a list of available help files for functions beginning with 's'. This autocomplete feature is very useful, and works for functions, variables, arguments and most things inbetween. Looking at the `seq()` help file, we can use the `from = ` and `to = ` argument to produce a sequence from 1 to 10.

```{r}
seq(from = 1, to = 10)
```

But, we don't always need to write the argument names.

```{r}
seq(1, 10)
```

It also doesn't have to have increments of 1.

```{r}
seq(1, 10, by = 0.5) # <1>
```

1. Except the first one or two arguments (function dependent) I would always use argument names.

We can specify the length instead of the increments.

```{r}
seq(1, 10, length.out = 14)
```

#### Dealing with `NA`'s

Missing data values in R appear as `NA`. We can create vectors (or matrices, dataframes, tibbles) with missing values.

```{r}
x1 <- c(1, -3, NA, 7, 17.2)
```

Lets use the `mean()` function to calculate the mean of `x1`.

```{r}
mean(x1)
```

The output is ``r mean(x1)``, which is sensible.^[R cannot read your mind, so doesn't know what to do with the missing value(s).] But, we can tell R to ignore the `NA` values when calculating the mean. Have a look at the help file, `?mean`, and see if you can do this.^[Hint: use the `na.rm` argument.]

#### Creating our own function {#sec-gettingStarted-functions}

Suppose we want to add together two numbers and divide by 5. We can do this in the console like so:
```{r}
number1 <- 6
number2 <- 12

(number1 + number2) / 5
```

Sometimes creating a function makes your code more readible and reduces repetition. Lets make a function that has two inputs, adds them together and divides by 5.

```{r}
add_then_divide <- function(x, y) {
  add_together <- x + y
  divide_by_five <- add_together / 5
  divide_by_five
}
```

Then, we can use this function to perform the operation.
```{r}
add_then_divide(x = number1, y = number2)
```

## Creating a plot {#sec-gettingStarted-plot}

In this chapter, we are going to produce a plot that looks like @fig-ggplot-outcome. This uses the {ggplot2} package, which is included in the {tidyverse} package we loaded earlier. We can also produce plots using base R functions^[e.g. try typing `plot(density(rnorm(100)))` to create a kernel density plot of 100 standard normal realisations.], but I feel like ggplot is more user friendly and can create nicer looking plots with less effort.

```{r}
#| echo: false
#| warning: false
#| label: fig-ggplot-outcome
#| fig-asp: 0.8
#| fig-cap: A figure showing the body mass and flipper length of three types of penguins, with a linear line of best fit.


library(palmerpenguins)

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(aes(color = species, shape = species)) +
  geom_smooth(method = "lm") +
  labs(
    title = "Body mass and flipper length",
    subtitle = "Dimensions for Adelie, Chinstrap, and Gentoo Penguins",
    x = "Flipper length (mm)", y = "Body mass (g)",
    color = "Species", shape = "Species"
  ) +
  scale_color_manual(values = c("#4477AA", "#EE6677", "#228833")) +
  theme_minimal()
```

This chapter is adapted from @wickham2023r[Data Visualisation chapter], which can be read online for free [here](https://r4ds.hadley.nz/data-visualize).

### The data

We will use data on penguins, obtained from the [{palmerpenguins}](https://allisonhorst.github.io/palmerpenguins/) package [@horst2020palmer]. This is a popular alternative to the [`iris` dataset](https://en.wikipedia.org/wiki/Iris_flower_data_set), which was created by Ronald Fisher.^[who was a eugenicist and took money from the tobacco industry to muddy the waters.]

First, you will need to install the {palmerpenguins} package.^[Hint, use `install.packages()`] Then, load the package into R, using `library()`. Then, the dataset can be viewed by:

```{r}
penguins
```

::: {.column-margin}
::: {.callout-note title="Factors"}

The `species` and `island` columns are *factors*, which are similar to SAS formats. We can see the values of the factors using `levels()`.

```{r}
levels(penguins$species)
```

:::
:::

This data frame contains `r ncol(penguins)` columns. Notice from the last line of the output above that there are two variables that are not shown, `sex <fct>, year <int>`. For an alternative view that allows you to see all variables and the first few observations of each variable, use `glimpse()`.

```{r}
glimpse(penguins)
```

Or, if you're in RStudio, run `View(penguins)` to open an interactive data viewer similar to how you would view a dataset in SAS.^[You can also double-click on the data in the top-right window in RStudio, under the 'Environment' tab.]


Among the variables in `penguins` are:

1.  `species`: a penguin's species (Adelie, Chinstrap, or Gentoo).

2.  `flipper_length_mm`: length of a penguin's flipper, in millimeters.

3.  `body_mass_g`: body mass of a penguin, in grams.

To learn more about `penguins`, open its help page by running `?penguins`.

### Creating a ggplot

Let's recreate the plot in @fig-ggplot-outcome step-by-step.

With ggplot2, you begin a plot with the function `ggplot()`, defining a plot object that you then add **layers** to.
The first argument of `ggplot()` is the dataset to use in the graph and so `ggplot(data = penguins)` creates an empty graph that is primed to display the `penguins` data, but since we haven't told it how to visualize it yet, for now it's empty.
This is not a very exciting plot, but you can think of it like an empty canvas you'll paint the remaining layers of your plot onto.

```{r}
#| fig-alt: |
#|   A blank, gray plot area.

ggplot(data = penguins)
```

Next, we need to tell `ggplot()` how the information from our data will be visually represented.
The `mapping` argument of the `ggplot()` function defines how variables in your dataset are mapped to visual properties (**aesthetics**) of your plot.
The `mapping` argument is always defined in the `aes()` function, and the `x` and `y` arguments of `aes()` specify which variables to map to the x and y axes.
For now, we will only map flipper length to the `x` aesthetic and body mass to the `y` aesthetic.
ggplot2 looks for the mapped variables in the `data` argument, in this case, `penguins`.

The following plot shows the result of adding these mappings.

```{r}
#| fig-alt: |
#|   The plot shows flipper length on the x-axis, with values that range from 
#|   170 to 230, and body mass on the y-axis, with values that range from 3000 
#|   to 6000.

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
)
```

Our empty canvas now has more structure -- it's clear where flipper lengths will be displayed (on the x-axis) and where body masses will be displayed (on the y-axis).
But the penguins themselves are not yet on the plot.
This is because we have not yet articulated, in our code, how to represent the observations from our data frame on our plot.

To do so, we need to define a **geom**: the geometrical object that a plot uses to represent data.
These geometric objects are made available in ggplot2 with functions that start with `geom_`.
People often describe plots by the type of geom that the plot uses.
For example, bar charts use bar geoms (`geom_bar()`), line charts use line geoms (`geom_line()`), boxplots use boxplot geoms (`geom_boxplot()`), scatterplots use point geoms (`geom_point()`), and so on.

The function `geom_point()` adds a layer of points to your plot, which creates a scatterplot.
ggplot2 comes with many geom functions that each adds a different type of layer to a plot.

```{r}
#| fig-alt: |
#|   A scatterplot of body mass vs. flipper length of penguins. The plot 
#|   displays a positive, linear, and relatively strong relationship between 
#|   these two variables.

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point()
```

Now we have something that looks like what we might think of as a "scatterplot".
It doesn't yet match our "ultimate goal" plot, but using this plot we can start answering the question that motivated our exploration: "What does the relationship between flipper length and body mass look like?" The relationship appears to be positive (as flipper length increases, so does body mass), fairly linear (the points are clustered around a line instead of a curve), and moderately strong (there isn't too much scatter around such a line).
Penguins with longer flippers are generally larger in terms of their body mass.

Before we add more layers to this plot, let's pause for a moment and review the warning message we got:

> Removed 2 rows containing missing values (`geom_point()`).

We're seeing this message because there are two penguins in our dataset with missing body mass and/or flipper length values and ggplot2 has no way of representing them on the plot without both of these values.
Like R, ggplot2 subscribes to the philosophy that missing values should never silently go missing.
This type of warning is probably one of the most common types of warnings you will see when working with real data -- missing values are a very common issue.
For the remaining plots in this chapter we will suppress this warning so it's not printed alongside every single plot we make.

### Adding aesthetics and layers

Scatterplots are useful for displaying the relationship between two numerical variables, but it's always a good idea to be skeptical of any apparent relationship between two variables and ask if there may be other variables that explain or change the nature of this apparent relationship.
For example, does the relationship between flipper length and body mass differ by species?
Let's incorporate species into our plot and see if this reveals any additional insights into the apparent relationship between these variables.
We will do this by representing species with different colored points.

To achieve this, will we need to modify the aesthetic or the geom?
If you guessed "in the aesthetic mapping, inside of `aes()`", you're already getting the hang of creating data visualizations with ggplot2!
And if not, don't worry.

```{r}
#| warning: false
#| fig-alt: |
#|   A scatterplot of body mass vs. flipper length of penguins. The plot 
#|   displays a positive, fairly linear, and relatively strong relationship 
#|   between these two variables. Species (Adelie, Chinstrap, and Gentoo) 
#|   are represented with different colors.

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)
) +
  geom_point()
```

When a categorical variable is mapped to an aesthetic, ggplot2 will automatically assign a unique value of the aesthetic (here a unique color) to each unique level of the variable (each of the three species), a process known as **scaling**.
ggplot2 will also add a legend that explains which values correspond to which levels.

Now let's add one more layer: a smooth curve displaying the relationship between body mass and flipper length.
Before you proceed, refer back to the code above, and think about how we can add this to our existing plot.

Since this is a new geometric object representing our data, we will add a new geom as a layer on top of our point geom: `geom_smooth()`.
And we will specify that we want to draw the line of best fit based on a `l`inear `m`odel with `method = "lm"`.

```{r}
#| warning: false
#| fig-alt: |
#|   A scatterplot of body mass vs. flipper length of penguins. Overlaid 
#|   on the scatterplot are three smooth curves displaying the 
#|   relationship between these variables for each species (Adelie, 
#|   Chinstrap, and Gentoo). Different penguin species are plotted in 
#|   different colors for the points and the smooth curves.

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)
) +
  geom_point() +
  geom_smooth(method = "lm")
```

We have successfully added lines, but this plot doesn't look like the plot from @fig-ggplot-outcome, which only has one line for the entire dataset as opposed to separate lines for each of the penguin species.

When aesthetic mappings are defined in `ggplot()`, at the *global* level, they're passed down to each of the subsequent geom layers of the plot.
However, each geom function in ggplot2 can also take a `mapping` argument, which allows for aesthetic mappings at the *local* level that are added to those inherited from the global level.
Since we want points to be colored based on species but don't want the lines to be separated out for them, we should specify `color = species` for `geom_point()` only.

```{r}
#| warning: false
#| fig-alt: |
#|   A scatterplot of body mass vs. flipper length of penguins. Overlaid 
#|   on the scatterplot is a single line of best fit displaying the 
#|   relationship between these variables for each species (Adelie, 
#|   Chinstrap, and Gentoo). Different penguin species are plotted in 
#|   different colors for the points only.

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(mapping = aes(color = species)) +
  geom_smooth(method = "lm")
```

Voila!
We have something that looks very much like our ultimate goal, though it's not yet perfect.
We still need to use different shapes for each species of penguins and improve labels.

It's generally not a good idea to represent information using only colors on a plot, as people perceive colors differently due to color blindness or other color vision differences.
Therefore, in addition to color, we can also map `species` to the `shape` aesthetic.

```{r}
#| warning: false
#| fig-alt: |
#|   A scatterplot of body mass vs. flipper length of penguins. Overlaid 
#|   on the scatterplot is a single line of best fit displaying the 
#|   relationship between these variables for each species (Adelie, 
#|   Chinstrap, and Gentoo). Different penguin species are plotted in 
#|   different colors and shapes for the points only.

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(mapping = aes(color = species, shape = species)) +
  geom_smooth(method = "lm")
```

Note that the legend is automatically updated to reflect the different shapes of the points as well.

And finally, we can improve the labels of our plot using the `labs()` function in a new layer.
Some of the arguments to `labs()` might be self explanatory: `title` adds a title and `subtitle` adds a subtitle to the plot.
Other arguments match the aesthetic mappings, `x` is the x-axis label, `y` is the y-axis label, and `color` and `shape` define the label for the legend.
In addition, we can improve the color palette to use colours obtained from the 'bright' colour pallette in Paul Tol's [website](https://personal.sron.nl/~pault/).
To remove the grey background, we can use a different theme that is included with {ggplot2}. Here we will use `theme_minimal()`, but other options can be found [on the website](https://ggplot2.tidyverse.org/reference/ggtheme.html).

```{r}
#| fig-asp: 0.8
#| warning: false
#| fig-alt: |
#|   A scatterplot of body mass vs. flipper length of penguins, with a 
#|   line of best fit displaying the relationship between these two variables 
#|   overlaid. The plot displays a positive, fairly linear, and relatively 
#|   strong relationship between these two variables. Species (Adelie, 
#|   Chinstrap, and Gentoo) are represented with different colors and 
#|   shapes. The relationship between body mass and flipper length is 
#|   roughly the same for these three species, and Gentoo penguins are 
#|   larger than penguins from the other two species.

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(aes(color = species, shape = species)) +
  geom_smooth(method = "lm") +
  labs(
    title = "Body mass and flipper length",
    subtitle = "Dimensions for Adelie, Chinstrap, and Gentoo Penguins",
    x = "Flipper length (mm)", y = "Body mass (g)",
    color = "Species", shape = "Species"
  ) +
  scale_color_manual(values = c("#4477AA", "#EE6677", "#228833")) +
  theme_minimal()
```

We finally have a plot that matches that shown in @fig-ggplot-outcome!

## The Tidyverse

The tidyverse is a set of tools, originally created by [Hadley Wickham](https://hadley.nz/). All the packages within tidyverse share the same underlying design philosophy. 

One key idea of the tidyverse is the *pipe*, either `%>%` or `|>`. The pipe can be thought of as a process for taking a tibble (or dataframe) on the left, and performing some function to it on the right. For example, to take the `penguins` dataset used in @sec-gettingStarted-plot and add a new variable that is the sum of the `bill_length_mm` and `flipper_length_mm`, we can use the `mutate()` function (from the [{dplyr} package](https://dplyr.tidyverse.org/)).

```{r}
penguins |>
  mutate(sum_of_bill_flipper = bill_length_mm + flipper_length_mm) |> # <1>
  glimpse()
```
1. Notice that here, we do not need to write `penguins$bill_length_mm`. This is because the pipe is telling `mutate()` that the dataset is `penguins`.

::: {.callout-important}

# The Pipe

Because of how popular the pipe has become, the pipe `|>` is now included in base R. The other pipe, `%>%`, is from the {magrittr} package. I will just use the base pipe here `|>`, although there are some slight differences as explained in the [tidyverse blog](https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/). 

Note that if your version of R is less that 4.1.0, the base pipe is not available. Therefore you will have to load tidyverse, `library(tidyverse)`, and use the {magrittr} pipe `%>%`.
:::

### Examples of data wrangling in the tidyverse

Sticking with our `penguins` dataset, lets do some wrangling. Here we use functions that are part of the {dplyr} package, which is included in the tidyverse.

What if we want to find the average bill length per year?

```{r}
penguins |> # <1>
  group_by(year) |> # <2>
  summarise(average_bill = mean(bill_length_mm, na.rm = TRUE)) # <3>
```

1. Start with the `penguins` dataset
2. Group by the year, so any functions after this point are performed on each year seperately
3. Use the [`summarise` function](https://dplyr.tidyverse.org/reference/summarise.html) to find the mean. We need to use `na.rm = TRUE` to remove the `NA` values.

We haven't saved this summary dataset, as we did not assign it to a new variable.[^note1]

[^note1]: To assign it to a variable we need to use the `<-` operator:  
    ```{r}
    penguins_year_summary <- penguins |>
      group_by(year) |>
      summarise(average_bill = mean(bill_length_mm, na.rm = TRUE))
    ```

We can group by multiple variables. Here, we are finding the average bill length for each year and each species.

```{r}
penguins |>
  group_by(year, species) |> 
  summarise(average_bill = mean(bill_length_mm, na.rm = TRUE)) 
```

#### Using `mutate()`

The `mutate()` function creates new columns that are functions of existing variables. It can also modify and delete columns.

```{r}
# square the body mass
penguins |>
  mutate(body_mass_squared_g = body_mass_g^2)
```
Look at the last line of the output above, `3 more variables: sex <fct>, year <int>, body_mass_squared_g <dbl>`. Our new variable is there, but is hidden. The `mutate()` function always includes new columns at the end of the dataset. Here, we can use `glimpse()` to be able to see our new column. We can also tell `mutate()` where we want it to put the column.^[Before going on, see if you can figure out how to do this by looking at the help file, `?mutate`.]
```{r}
# using glimpse()
penguins |>
  mutate(body_mass_squared_g = body_mass_g^2) |>
  glimpse() # <1>
```
```{r}
# telling mutate() that we want the column to go after the 'body_mass_g' column
penguins |>
  mutate(body_mass_squared_g = body_mass_g^2, .after = body_mass_g) |>
  glimpse()
```
1. Notice that `glimpse()` doesn't have any arguments. That is because the pipe `|>` inputs the data into the argument of `glimpse()`.

```{r}
# normalise the bill depth by the sample mean
penguins |>
  mutate(bill_depth_norm = bill_depth_mm / mean(bill_depth_mm, na.rm = TRUE))
```

Performing operations on multiple columns: here we are using the `across()` function to round the columns `bill_length_mm`, `bill_depth_mm`, and `flipper_length_mm` to the nearest integer. Note that here the columns are overwritten.

```{r}
penguins |>
  mutate(across(c(bill_length_mm, bill_depth_mm, flipper_length_mm), round))
```

#### Using `select()`

We can use `select()` to select columns. The `:` operator selects a range of consecutive variables. The `!` operator negates a selection.

```{r}
penguins |>
  select(sex)

penguins |>
  select(body_mass_g:year)

penguins |>
  select(!sex)
```

You can also select based on the name of the variables. Here we will select all variables that end with "_mm".^[See the [tidyselect website](https://tidyselect.r-lib.org/reference/starts_with.html) for more information on pattern matching.]

```{r}
penguins |>
  select(ends_with("_mm"))
```

Or, all variables that do not end in "_mm", using the `!` operator.
```{r}
penguins |>
  select(!ends_with("_mm"))
```

#### Using `filter()`

The [`filter()` function](https://dplyr.tidyverse.org/reference/filter.html) keeps rows that match a condition.

For example, if we want to keep all rows that satisfy some condition on the bill length.
```{r}
# bill length must be greater than 40mm
penguins |>
  filter(bill_length_mm > 40)

# bill length less than or equal to 35mm
penguins |>
  filter(bill_length_mm <= 35)

# bill length is greater than the mean bill length
penguins |>
  filter(bill_length_mm > mean(bill_length_mm, na.rm = TRUE))

```

We can also filter after grouping the variables. For example, if we want to only keep rows where the bill length is less than the mean bill length *for that specific species*, we can group by species before filtering.

```{r}
penguins |>
  group_by(species) |>
  filter(bill_length_mm > mean(bill_length_mm, na.rm = TRUE))
```

In the ungrouped version, `filter()` compares the value of `bill_length_mm` in each row to the global average (taken over the whole data set), keeping only the rows with `bill_length_mm` greater than this global average. In contrast, the grouped version calculates the average `bill_length_mm` separately for each `species` group, and keeps rows with `bill_length_mm` greater than the relevant within-species average.

#### Using `arrange()`

We can use `arrange()` to order the rows of a data frame.

```{r}
# arrange by body mass in ascending order
penguins |>
  arrange(body_mass_g)

# arrange by body mass in descending order
penguins |>
  arrange(desc(body_mass_g))

# arrange by bill length and flipper length
penguins |>
  arrange(bill_length_mm, flipper_length_mm)
```  

Note that `arrange()` ignores groupings unless specifically told not to. Have a look at the help file, `?arrange` to see for yourself.

```{r}
# group penguins by species
penguins_grouped <- penguins |> 
  group_by(species)

# arrange() ignores grouping
penguins_grouped |>
  arrange(body_mass_g)

# telling arrange() not to ignore the grouping
penguins_grouped |>
  arrange(body_mass_g, .by_group = TRUE)
```

## Linear and logistic regression

## Performing survival analysis

To perform survival analysis in R, we need to get the [{survival} package](https://cran.r-project.org/package=survival).

```{r}
library(survival)
```

### Loading the example data

The {survival} package comes with lots of example dataset (write `data(package = "survival")` to see a list of them). We will be using the `lung` dataset. Currently, `lung` is a `data.frame`^[which can be seen by calling `class(lung)`], so lets convert to a tibble and view it.

```{r}
lung <- as_tibble(lung)

glimpse(lung)
```

We can look at the help file to see the desciptions of the variables by writing `?lung` in the console.

- `inst`: Institution code  
- `time`: Survival time in days  
- `status`: censoring status 1=censored, 2=dead  
- `age`: Age in years  
- `sex`: Male=1 Female=2  
- `ph.ecog`: ECOG performance score as rated by the physician. 0=asymptomatic, 1=symptomatic but completely ambulatory, 2=in bed <50% of the day, 3=in bed >50% of the day but not bedbound, 4=bedbound  
- `ph.karno`: Karnofsky performance score (bad=0-good=100) rated by physician  
- `pat.karno`: Karnofsky performance score as rated by patient  
- `meal.cal`: Calories consumed at meals  
- `wt.loss`: Weight loss in last six months (pounds)  

First, notice that all these variables are coded as `<dbl>`, *i.e.* floating point numbers. I want `inst`, `status`, `sex`, and `ph.ecog` to be factors. To do this, we use the `as_factor()` function from the {forcats} package (included in the tidyverse). Lets also change the levels of `sex` to "Male" and "Female" to make it clearer.

```{r}
lung <- lung |> # <1>
  mutate(
    across(c(inst, status, sex, ph.ecog), as_factor), # convert variables to factors
    sex = fct_recode(sex, Male = "1", Female = "2") # recode "1" to "Male" and "2" to "Female"
  )
```
1. Here we are replacing the original `lung` dataset with our new one.

Lets have a look at how many individuals were censored, and how many died.
```{r}
lung |>
  count(status)
```

```{r}
#| include: false
lung_counts <- lung |>
  count(status) |>
  select(n)
```

So, we have `r lung_counts[1,]` individuals who were censored, and `r lung_counts[2,]` who died. The first thing to notice here is that the `status` variable is coded in a unusual way. Normally, this variable would be `0` for censored and `1` for dead. So, lets recode. Normally we would use the `recode()` function, but as we are dealing with factors, we can use `fct_recode()` instead.^[The `recode()` function would still work, but it transforms the column back to a `<dbl>`.]

```{r}
lung <- lung |>
  mutate(
    status = fct_recode(status, `0` = "1", `1` = "2") 
  )
# check that the frequency is still the same, but with the new coding
lung %>%
  count(status)
```

OK, we have a nicer dataset now. Lets look at doing some survival analysis.

### Creating a survival object

The core functions of the {survival} package include:

- `Surv()`: Creates a survival object.
- `survfit()`: Fits a survival curve using either a formula, of from a previously fitted Cox model.
- `coxph()`: Fits a Cox proportional hazards regression model.
- `cox.zph()`: Tests the proportional hazards assumption of a Cox regression model.
- `survdiff()`: Tests for differences in survival between two groups using a log-rank / Mantel-Haenszel test.6

To create a survival object from our `lung` dataset, we can run the following.

```{r}
s <- Surv(lung$time, lung$status)

# lets look at the first ten elements of the output
s[1:10]
```
Run `class(s)` is your console to check that `s` is a survival object, `Surv`. The elements of a survival object are in the format `<time>:<status>` or `<time>+`, where

- `<time>` is the survival time (here, days).
- `<status>` indicates whether the event occurred (`1` for death) or the observation was censored (`0` for censored).
- The `+` symbol represents censored observations.

For example,

- `306:1:` This individual died after 306 days.
- `1022+:` This individual was alive (censored) after 1022 days.
- `731:1:` This individual died after 731 days.

::: {.callout-note}
# Did we need to recode the `status` variable?

Run `?Surv` in the console and have a look at the "Note" section near the bottom. 

*A question*: what would the output look like if we didn't record the `status` variable to 0 / 1?
:::

### Fitting a survival curve

To fit a survival curve, we use the `survfit()` function. To create a simple survival curve that doesn't consider any different groupings, we just specify the intercept, `~1`, in the `formula` argument.^[Look at `?survfit` for help.]

```{r}
sfit <- survfit(s ~ 1) #<1>

sfit
```

1. There are different ways to write this. For example, if we hadn't already created our survival object `s`, we could do it all in one line, `survfit(Surv(time, status) ~ 1, data = lung)`

The output from `sfit` shows some things,[^note2] but for a more interesting output, we can use the `summary()` function to show the number at risk and the cumulative survival at each event.
Here, I have put the output of the `summary()` function into a different tab, so that it doesn't take up lots of space.

[^note2]: The key components of `sfit` are:

    - `n`: The total number of individuals in the dataset (228).
    - `nevent`: The number of events (deaths) observed in the data (165).
    - `rmean`: The restricted mean survival time (time spent in a particular state up to a maximum time of 1022 days). It is broken into two states:
      - `(s0)`: Time in the "alive" state before transitioning (376.27 days on average).
      - `1`: Time in the "event" state (645.73 days on average).
    - `se(rmean)`: Standard error of the restricted mean survival time.

  
::: {.panel-tabset}

# R code
```{r}
#| eval: false

summary(sfit)
```

# Output
```{r}
#| echo: false

summary(sfit)
```

:::

The `summary()` function gives a more detailed breakdown of the Kaplan-Meier survival curve at specific time points, including:

- `time`: Specific time points where an event (death) occurred or censoring was recorded.
- `n.risk`: The number of individuals at risk of experiencing the event at that time.
- `n.event`: The number of events (deaths) that occurred at each time point.
- `Pr((s0))`: The survival probability (*i.e.* the probability of staying in the initial state (alive) at that time).
- `Pr(1)`: The cumulative probability of transitioning to the event state (death), *i.e.* $1 - $ survival probability.

For example, at `time = 5`, we have:

- `n.risk`: 228 individuals at risk at day 5.
- `n.event`: 1 individual died at day 5.
- `Pr((s0)) = 0.9956`: Survival probability after day 5 is 99.56%.
- `Pr(1) = 0.00439`: Cumulative probability of death by day 5 is 0.44%.
